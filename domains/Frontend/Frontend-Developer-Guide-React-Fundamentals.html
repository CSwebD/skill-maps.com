<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Frontend Developer Guide - React Fundamentals</title>
  <link rel="icon" href="../../images/logo.jpg" type="image/x-icon">
  <link rel="stylesheet" type="text/css" href="../style2.css">
  <meta name="description" content="Complete frontend developer roadmap from beginner to advanced. Master HTML, CSS, JavaScript, React, and modern web development." />
  <meta property="og:title" content="Frontend Developer Roadmap | Skill Maps" />
  <meta property="og:description" content="Learn frontend development through structured levels, from web basics to advanced PWAs and TypeScript." />
  <meta property="og:url" content="https://www.skill-maps.com/frontend-developer.html" />
  <meta property="og:image" content="https://www.skill-maps.com/logo.jpg" />

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" />
</head>
<body>
  <!-- NAVBAR -->
  <div id="panel-bar-placeholder"></div>
  <script src="panel-nav.js"></script>

  
  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>

  <!-- Mobile Content Toggle Button -->
  <button class="mobile-content-toggle" id="mobileContentToggle">
    <i class="fas fa-bars"></i>
    Content
  </button>


  <div class="course-container">
    <!-- SIDEBAR -->
    <aside class="sidebar" id="sidebar">
      <button class="sidebar-close-btn" id="sidebarCloseBtn">×</button>
      <div class="resizer" id="resizer"></div>
      <div class="sidebar-header">
        <a href="../../domains.html" class="back-button">← Back to Home</a>
        <h1 class="page-title">Frontend Developer</h1>
        <span style="font-size: 13px; color: #377536; display: block; margin-top: -10px; margin-bottom: 15px;">Full Course</span>
      </div>

      <!-- Introduction -->
      <h2>Getting Started</h2>
      <h3><a href="Frontend-Developer-Guide-Main.html">Introduction</a></h3>

      <!-- Step 1: HTML & CSS Fundamentals -->
      <h2>HTML & CSS Fundamentals</h2>
      <h3><a href="Frontend-Developer-Guide-Html.html">1. HTML Basics</a></h3>
      <h3><a href="Frontend-Developer-Guide-CSS.html">2. CSS Basics</a></h3>
      <h3><a href="Frontend-Developer-Guide-Developer-Tools.html">3. Developer Tools & Setup</a></h3>

      <!-- Step 2: JavaScript Fundamentals -->
      <h2>JavaScript Fundamentals</h2>
      <h3><a href="Frontend-Developer-Guide-JavaScript.html">4. JavaScript Basics</a></h3>
      <h3><a href="Frontend-Developer-Guide-DOM-Manipulation.html">5. DOM Manipulation</a></h3>
      <h3><a href="Frontend-Developer-Guide-Advanced-JavaScript.html">6. Advanced JavaScript</a></h3>

      <!-- Step 3: Responsive Design & Layout -->
      <h2>Responsive Design & Layout</h2>
      <h3><a href="Frontend-Developer-Guide-Responsive-Design.html">7. Responsive Design</a></h3>
      <h3><a href="Frontend-Developer-Guide-Modern-CSS-Layout.html">8. Modern CSS Layout</a></h3>
      <h3><a href="Frontend-Developer-Guide-CSS-Frameworks.html">9. CSS Frameworks</a></h3>

      <!-- Step 4: Version Control -->
      <h2>Version Control</h2>
      <h3><a href="Frontend-Developer-Guide-Git-&-GitHub.html">10. Git & GitHub</a></h3>

      <!-- Step 5: React & State Management -->
      <h2>React & State Management</h2>
      <h3><a href="Frontend-Developer-Guide-React-Fundamentals.html">11. React Fundamentals</a></h3>
      <h3><a href="Frontend-Developer-Guide-State-Management.html">12. State Management</a></h3>

      <!-- Step 6: APIs & Data -->
      <h2>APIs & Data</h2>
      <h3><a href="Frontend-Developer-Guide-Working-with-APIs.html">13. Working with APIs</a></h3>

      <!-- Step 7: Testing & Performance -->
      <h2>Testing & Performance</h2>
      <h3><a href="Frontend-Developer-Guide-Testing.html">14. Testing</a></h3>
      <h3><a href="Frontend-Developer-Guide-Performance-&-Optimization.html">15. Performance & Optimization</a></h3>

      <!-- Step 8: Documentation & Deployment -->
      <h2>Documentation & Deployment</h2>
      <h3><a href="Frontend-Developer-Guide-Documentation-&-UX.html">16. Documentation & UX</a></h3>
      <h3><a href="Frontend-Developer-Guide-Deployment.html">17. Deployment</a></h3>

      <!-- Step 9: Progressive Web Apps -->
      <h2>Progressive Web Apps</h2>
      <h3><a href="Frontend-Developer-Guide-Progressive-Web-Apps.html">18. Progressive Web Apps</a></h3>

      <!-- Step 10: Advanced Topics -->
      <h2>Advanced Topics</h2>
      <h3><a href="Frontend-Developer-Guide-TypeScript.html">19. TypeScript</a></h3>
      <h3><a href="Frontend-Developer-Guide-Web-Accessibility.html">20. Web Accessibility</a></h3>
      <h3><a href="Frontend-Developer-Guide-Security-Basics.html">21. Security Basics</a></h3>

      <h2 style="font-weight: 700; color: #377536;">Final Projects</h2>
      <h3><a href="Frontend-Developer-Guide-Portfolio-Projects.html">Portfolio Projects</a></h3>
    </aside>

    <!-- CONTENT -->
    <main class="content" id="content">
      <div class="content-header">
        <h1>Frontend Development Course</h1>
      </div>

      <!-- Ad Block: After HTML Section -->
      <div style="margin: 40px 0; text-align: center;">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7439109164508333"
             crossorigin="anonymous"></script>
        <!-- Index-Header -->
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-7439109164508333"
             data-ad-slot="4111274044"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      </div>

      <!-- STEP 1: HTML & CSS FUNDAMENTALS -->
      <h2 id="html-basics">11. React Fundamentals</h2>
      
      <!-- Navigation Buttons Top -->
      <div class="nav-buttons">
        <a href="Frontend-Developer-Guide-Git-&-GitHub.html" class="nav-btn nav-btn-prev">Git & GitHub</a>
        <a href="Frontend-Developer-Guide-State-Management.html" class="nav-btn nav-btn-next">State Management</a>
      </div>
      
      <p>React is a JavaScript library for building user interfaces through composable components, revolutionising modern frontend development.</p>
      
      <h4>Free Resources:</h4>
      <div class="resource-item">
        <span class="resource-badge video-badge">Video</span>
        <a href="https://www.youtube.com/watch?v=SqcY0GlETPk" target="_blank" class="resource-link">Tutorial: React Tutorial for Beginners</a>
      </div>
      <div class="resource-item">
        <span class="resource-badge video-badge">Video</span>
        <a href="https://www.youtube.com/watch?v=Rh3tobg7hEo" target="_blank" class="resource-link">Mini Project: Learn React With This One Project</a>
      </div>
      <div class="resource-item">
        <span class="resource-badge book-badge">Book</span>
        <a href="https://www.amazon.co.uk/React-Step-Step-Mastering-Development/dp/B0CRRNZNSF" target="_blank" class="resource-link">React JS: A Step-by-Step Guide</a>
      </div>
      <div class="resource-item">
        <span class="resource-badge article-badge">Article</span>
        <a href="https://react.dev/" target="_blank" class="resource-link">React Docs</a>
      </div>

      <h4>General Information:</h4>
      <p>React is a JavaScript library for building user interfaces through composable components. Created by Facebook, React has become the most popular choice for frontend development due to its component-based architecture, declarative approach, and enormous ecosystem. React breaks UIs into independent, reusable pieces called components—think of them as custom HTML elements. Components can be small (like a button) or large (like an entire page), and can contain other components, creating nested structures. This composition model makes complex UIs manageable by breaking them into understandable pieces.</p>
      <p>React uses JSX (JavaScript XML), a syntax extension that lets you write HTML-like code in JavaScript. JSX looks like HTML but is more powerful—you can embed JavaScript expressions in curly braces: <code>&lt;h1&gt;Hello {name}&lt;/h1&gt;</code>. Under the hood, JSX compiles to JavaScript function calls. Whilst JSX isn't required, it makes React code more readable and intuitive. React uses a virtual DOM—an in-memory representation of the actual DOM—to efficiently update the UI. When data changes, React compares the virtual DOM to the actual DOM and only updates what changed. This makes React fast despite seeming wasteful.</p>
      <p>Modern React uses functional components with hooks rather than class components (which are now legacy). Hooks are functions that let you "hook into" React features like state and lifecycle events from functional components. The two most essential hooks are <code>useState</code> for managing component state and <code>useEffect</code> for side effects. React's unidirectional data flow (data flows from parent to child via props) makes applications predictable and easier to debug. Learning React means learning to think in components, understand when to lift state up or use context, and embrace immutability. Once these concepts click, React feels natural and powerful.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: React in 100 Seconds</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/V9i3cGD-mts?si=BT9fXz5yq9QCmX-n" title="React Fundamentals" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>

      <h4>Components & JSX:</h4>
      <p>React components are the building blocks of React applications, encapsulating HTML structure, styling, and behaviour into reusable pieces. Functional components are JavaScript functions that return JSX—the UI the component renders. A simple component looks like: <code>function Welcome() { return &lt;h1&gt;Hello!&lt;/h1&gt;; }</code>. Components can accept inputs called "props" (short for properties), making them dynamic and reusable: <code>function Welcome({ name }) { return &lt;h1&gt;Hello {name}!&lt;/h1&gt;; }</code>. Props flow from parent to child, creating a unidirectional data flow that makes applications predictable and easier to debug.</p>
      <p>JSX is React's syntax for describing UI, combining the familiarity of HTML with the power of JavaScript. Whilst it looks like HTML, JSX has important differences: use <code>className</code> instead of <code>class</code> (since class is a JavaScript keyword), camelCase for event handlers (<code>onClick</code> not <code>onclick</code>), and self-closing tags must include the slash (<code>&lt;img /&gt;</code> not <code>&lt;img&gt;</code>). You can embed any JavaScript expression in JSX using curly braces: variables, function calls, ternary operators, and more. JSX expressions can include conditional rendering: <code>{isLoggedIn ? &lt;Dashboard /&gt; : &lt;Login /&gt;}</code> and array mapping: <code>{items.map(item =&gt; &lt;Item key={item.id} data={item} /&gt;)}</code>.</p>
      <p>Component composition is React's superpower. Build small, focused components and combine them into larger ones. A <code>&lt;Card&gt;</code> component might contain <code>&lt;CardHeader&gt;</code>, <code>&lt;CardBody&gt;</code>, and <code>&lt;CardFooter&gt;</code> components. This composition model makes code maintainable and testable. Components should be pure functions as much as possible—given the same props, they return the same output without side effects. The <code>children</code> prop is special, representing content nested inside component tags: <code>&lt;Card&gt;&lt;p&gt;Content&lt;/p&gt;&lt;/Card&gt;</code> passes the paragraph as children. Understanding component composition and the props system is fundamental to React mastery.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: React Components and Props</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/Rh3tobg7hEo?si=P8i5YTp0K6d_Dsia" title="React Components" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>

      <h4>State with useState:</h4>
      <p>State is data that changes over time and affects what a component renders. Unlike props (which are passed from parent and immutable in the child), state is owned and managed by the component itself. The <code>useState</code> hook adds state to functional components: <code>const [count, setCount] = useState(0)</code> creates a state variable <code>count</code> initialised to 0 and a function <code>setCount</code> to update it. Array destructuring lets you name these whatever you want. When state updates, React re-renders the component with the new value, reflecting changes in the UI immediately.</p>
      <p>State updates are asynchronous and may be batched for performance. Never mutate state directly—always use the setter function: <code>setCount(count + 1)</code> not <code>count = count + 1</code>. For objects and arrays, create new copies rather than modifying existing ones: <code>setUser({...user, name: 'New Name'})</code> for objects, <code>setItems([...items, newItem])</code> for arrays. The spread operator is essential for immutable updates. When new state depends on old state, use the functional update form: <code>setCount(prevCount =&gt; prevCount + 1)</code>. This ensures you're working with the latest value, especially important when updates happen rapidly.</p>
      <p>Each piece of state should have a single source of truth. If multiple components need the same state, lift it up to their closest common ancestor and pass it down via props. Related state that changes together should be grouped in an object rather than separate <code>useState</code> calls. State should contain only values that affect rendering—derived values can be calculated during render. Understanding when and how to use state versus props, when to lift state up, and how to update state immutably are fundamental React skills that separate beginners from proficient developers.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: useState Hook Explained</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/4pO-HcG2igk?si=9kiRc5JeEQnD4RmM" title="useState Hook" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>

      <h4>Effects with useEffect:</h4>
      <p>The <code>useEffect</code> hook handles side effects in functional components—operations that reach outside your component like data fetching, subscriptions, timers, or manually changing the DOM. Effects run after render, ensuring the DOM is updated before your side effect code executes. Basic syntax: <code>useEffect(() =&gt; { /* effect code */ })</code>. Without a dependency array, this runs after every render. Side effects should never run during render itself—they belong in <code>useEffect</code>, event handlers, or other lifecycle hooks.</p>
      <p>The dependency array controls when effects run: <code>useEffect(() =&gt; { /* effect */ }, [dependency1, dependency2])</code> runs only when dependencies change. An empty array <code>[]</code> runs the effect only once after initial render (like componentDidMount in class components), useful for initial data fetching or setting up subscriptions. Include all values from component scope used inside the effect in the dependency array, or you'll have stale closures and bugs. React's exhaustive-deps ESLint rule helps catch missing dependencies. When in doubt, include it—unnecessary re-runs are better than bugs from stale data.</p>
      <p>Cleanup prevents memory leaks and unexpected behaviour. Return a cleanup function from your effect to run before the component unmounts or before the effect runs again: <code>useEffect(() =&gt; { const timer = setTimeout(...); return () =&gt; clearTimeout(timer); }, [])</code>. This is essential for subscriptions, event listeners, timers, and any resource that needs explicit cleanup. Effects are powerful but can cause performance issues if overused—not everything needs to be in <code>useEffect</code>. Prefer deriving values during render, using event handlers for user interactions, and reserving <code>useEffect</code> for genuine side effects that must happen after render.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: useEffect Hook Explained</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/YxkcMszKEYY?si=yhEdZeMWBnwfVyZG" title="useEffect Hook" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>

      <h4>Lists & Keys:</h4>
      <p>Rendering lists is a common pattern in React—displaying arrays of data as arrays of components. Use JavaScript's <code>map()</code> method to transform data arrays into component arrays: <code>const items = data.map(item =&gt; &lt;ListItem key={item.id} data={item} /&gt;)</code>. This declarative approach feels natural once you understand that JSX expressions can include arrays of elements. The result is clean, readable code that directly expresses the relationship between your data and UI. List rendering is how you build dynamic UIs that grow and shrink with data.</p>
      <p>Keys are special attributes that help React identify which items changed, were added, or removed. Keys must be unique amongst siblings (but not globally), stable (same item gets same key across renders), and predictable. The best keys are unique IDs from your data: <code>key={item.id}</code>. Never use array indices as keys for dynamic lists—if items reorder or are deleted, indices change, causing React to reuse component instances incorrectly, leading to bugs with component state and inputs. Keys aren't props—components don't receive them. They're purely for React's reconciliation algorithm.</p>
      <p>Poor key choices cause subtle bugs and performance issues. React uses keys to match old elements to new ones during updates. With proper keys, React efficiently updates only what changed. With poor keys (or no keys), React recreates elements unnecessarily, losing component state and degrading performance. If you don't have unique IDs, generate them when loading data (libraries like uuid help) or restructure your data to include IDs. Understanding keys deeply prevents a whole class of confusing bugs and makes dynamic lists work correctly.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: React Lists and Keys</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/fGxKOmCuH5w?si=7JXZvZ8GTWRSKdHc" title="React Lists" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>

      <h4>Forms & Controlled Components:</h4>
      <p>Forms in React use controlled components—form elements whose values are controlled by React state rather than the DOM. For inputs, set the <code>value</code> prop to a state variable and handle changes with <code>onChange</code>: <code>&lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;</code>. This makes React the single source of truth for form data, enabling validation, formatting, and dynamic behaviour. The input's displayed value always matches state, and state updates on every keystroke through the onChange handler. This pattern feels verbose initially but provides complete control over form behaviour.</p>
      <p>Different form elements have different controlled patterns. Text inputs and textareas use <code>value</code> and <code>onChange</code>. Checkboxes use <code>checked</code> and <code>onChange</code>: <code>&lt;input type="checkbox" checked={agreed} onChange={e =&gt; setAgreed(e.target.checked)} /&gt;</code>. Select elements use <code>value</code> on the <code>&lt;select&gt;</code> tag, not individual <code>&lt;option&gt;</code> tags: <code>&lt;select value={choice} onChange={e =&gt; setChoice(e.target.value)}&gt;</code>. Radio buttons use <code>checked</code> with the same <code>name</code> attribute. For multiple inputs, use a single onChange handler that checks <code>event.target.name</code> to determine which input changed, updating an object state accordingly.</p>
      <p>Form submission prevents default browser behaviour with <code>event.preventDefault()</code> in the submit handler. This lets you handle data with JavaScript instead of traditional form POST requests. Validate inputs as users type (for immediate feedback) or on blur (less intrusive) or on submit (final validation). Display error messages conditionally based on validation state. Disable submit buttons whilst forms are invalid or submitting. Consider libraries like Formik or React Hook Form for complex forms—they handle validation, error messages, and submission patterns, reducing boilerplate. Mastering controlled components is essential for interactive React applications.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: React Forms Tutorial</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/X2O7Wfmkuzw?si=e9-QbQhpkyIkyPwM" title="React Forms" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>

      <h4>Component Lifecycle:</h4>
      <p>React functional components with hooks have a simpler mental model than class component lifecycle methods, but understanding the component lifecycle is still important. Components go through three phases: mounting (initial render, component added to DOM), updating (subsequent re-renders when props or state change), and unmounting (component removed from DOM). Each phase has corresponding patterns in hooks. During mounting, <code>useState</code> initialises state, <code>useEffect</code> with empty dependencies runs setup code. During updates, <code>useEffect</code> with dependencies runs side effects when specific values change. During unmounting, <code>useEffect</code> cleanup functions run.</p>
      <p>The render phase is pure—components should be pure functions that return the same output given the same inputs, without side effects. Side effects belong in <code>useEffect</code> or event handlers, never directly in the component body. React may call your component function multiple times before committing to the DOM (Concurrent React), so side effects in render would run multiple times unpredictably. The commit phase follows rendering—React updates the DOM, then runs <code>useEffect</code> effects. Browser paints the screen, then effects run, ensuring DOM changes are visible before side effect code executes.</p>
      <p>Understanding when and why re-renders occur prevents performance issues and bugs. Components re-render when their state changes, when their parent re-renders (unless memoised), or when context values they use change. Props changes don't directly cause re-renders—the parent re-rendering with new props does. React's default behaviour is to re-render all children when a component re-renders. Whilst usually fine, this can be optimised with <code>React.memo()</code>, <code>useMemo()</code>, and <code>useCallback()</code> for expensive computations or components. However, premature optimisation causes more issues than it solves—optimise only when profiling reveals actual performance problems.</p>
      <div class="highlight-box" style="margin-top: 25px;">
        <p style="margin-bottom: 15px;"><strong>Video Tutorial: React Component Lifecycle</strong></p>
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/qnN_FuFNq2g?si=fYDHivYNz-Io34oX" title="Component Lifecycle" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
        <p style="margin-top: 15px">Source: Youtube</p>
      </div>
      
      <h4>React Core Concepts:</h4>
      <ul class="topic-list">
        <li><strong>Components:</strong> Functional components, JSX syntax, props</li>
        <li><strong>State:</strong> useState hook, managing component state</li>
        <li><strong>Effects:</strong> useEffect hook, side effects, cleanup</li>
        <li><strong>Lists & keys:</strong> Rendering lists efficiently, unique keys</li>
        <li><strong>Forms:</strong> Controlled components, handling input</li>
        <li><strong>Component lifecycle:</strong> Mounting, updating, unmounting phases</li>
      </ul>

      <!-- Ad Block: After HTML Section -->
      <div style="margin: 40px 0; text-align: center;">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7439109164508333"
             crossorigin="anonymous"></script>
        <!-- Index-Header -->
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-7439109164508333"
             data-ad-slot="4111274044"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      </div>

      <!-- Navigation Buttons Bottom -->
      <div class="nav-buttons">
        <a href="Frontend-Developer-Guide-Git-&-GitHub.html" class="nav-btn nav-btn-prev">Git & GitHub</a>
        <a href="Frontend-Developer-Guide-State-Management.html" class="nav-btn nav-btn-next">State Management</a>
      </div>
    </main>
  </div>

  <!-- Placeholder for the footer -->
  <div id="footer-placeholder"></div>
  <script src="../../analytics.js"></script>
  <script src="../../nav-switcher.js"></script>
  <script src="footer.js"></script>
  <script src="../script.js"></script>

  <script>
    // Sidebar resizer functionality
    const resizer = document.getElementById('resizer');
    const sidebar = document.getElementById('sidebar');
    
    let isResizing = false;
    
    resizer.addEventListener('mousedown', (e) => {
      isResizing = true;
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      
      const newWidth = e.clientX;
      if (newWidth >= 200 && newWidth <= 500) {
        sidebar.style.width = newWidth + 'px';
      }
    });
    
    document.addEventListener('mouseup', () => {
      isResizing = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    });

    // Mobile sidebar toggle
    const mobileToggle = document.getElementById('mobileContentToggle');
    const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
    
    if (mobileToggle) {
      mobileToggle.addEventListener('click', () => {
        sidebar.classList.toggle('mobile-open');
      });
    }
    
    if (sidebarCloseBtn) {
      sidebarCloseBtn.addEventListener('click', () => {
        sidebar.classList.remove('mobile-open');
      });
    }
  </script>
</body>
</html>